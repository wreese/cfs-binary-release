// Code generated by protoc-gen-go.
// source: group_api.proto
// DO NOT EDIT!

/*
Package groupproto is a generated protocol buffer package.

It is generated from these files:
	group_api.proto

It has these top-level messages:
	EmptyMsg
	WriteRequest
	LookupRequest
	ReadRequest
	DeleteRequest
	LookupGroupRequest
	ReadGroupRequest
	WriteResponse
	LookupResponse
	LookupGroupResponse
	LookupGroupItem
	ReadGroupResponse
	ReadGroupItem
	ReadResponse
	DeleteResponse
*/
package groupproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type EmptyMsg struct {
}

func (m *EmptyMsg) Reset()                    { *m = EmptyMsg{} }
func (m *EmptyMsg) String() string            { return proto.CompactTextString(m) }
func (*EmptyMsg) ProtoMessage()               {}
func (*EmptyMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type WriteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB" json:"childKeyB,omitempty"`
	Value          []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMicro int64  `protobuf:"varint,7,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type LookupRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB" json:"childKeyB,omitempty"`
}

func (m *LookupRequest) Reset()                    { *m = LookupRequest{} }
func (m *LookupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupRequest) ProtoMessage()               {}
func (*LookupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ReadRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB" json:"childKeyB,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type DeleteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,6,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type LookupGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
}

func (m *LookupGroupRequest) Reset()                    { *m = LookupGroupRequest{} }
func (m *LookupGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupRequest) ProtoMessage()               {}
func (*LookupGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ReadGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB" json:"keyB,omitempty"`
}

func (m *ReadGroupRequest) Reset()                    { *m = ReadGroupRequest{} }
func (m *ReadGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupRequest) ProtoMessage()               {}
func (*ReadGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type WriteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type LookupResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,3,opt,name=length" json:"length,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err" json:"err,omitempty"`
}

func (m *LookupResponse) Reset()                    { *m = LookupResponse{} }
func (m *LookupResponse) String() string            { return proto.CompactTextString(m) }
func (*LookupResponse) ProtoMessage()               {}
func (*LookupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type LookupGroupResponse struct {
	Rpcid uint32             `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	Items []*LookupGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string             `protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
}

func (m *LookupGroupResponse) Reset()                    { *m = LookupGroupResponse{} }
func (m *LookupGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupResponse) ProtoMessage()               {}
func (*LookupGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *LookupGroupResponse) GetItems() []*LookupGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type LookupGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,5,opt,name=length" json:"length,omitempty"`
}

func (m *LookupGroupItem) Reset()                    { *m = LookupGroupItem{} }
func (m *LookupGroupItem) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupItem) ProtoMessage()               {}
func (*LookupGroupItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ReadGroupResponse struct {
	Rpcid uint32           `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	Items []*ReadGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string           `protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
}

func (m *ReadGroupResponse) Reset()                    { *m = ReadGroupResponse{} }
func (m *ReadGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupResponse) ProtoMessage()               {}
func (*ReadGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ReadGroupResponse) GetItems() []*ReadGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ReadGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ReadGroupItem) Reset()                    { *m = ReadGroupItem{} }
func (m *ReadGroupItem) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupItem) ProtoMessage()               {}
func (*ReadGroupItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type ReadResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err" json:"err,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type DeleteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func init() {
	proto.RegisterType((*EmptyMsg)(nil), "groupproto.EmptyMsg")
	proto.RegisterType((*WriteRequest)(nil), "groupproto.WriteRequest")
	proto.RegisterType((*LookupRequest)(nil), "groupproto.LookupRequest")
	proto.RegisterType((*ReadRequest)(nil), "groupproto.ReadRequest")
	proto.RegisterType((*DeleteRequest)(nil), "groupproto.DeleteRequest")
	proto.RegisterType((*LookupGroupRequest)(nil), "groupproto.LookupGroupRequest")
	proto.RegisterType((*ReadGroupRequest)(nil), "groupproto.ReadGroupRequest")
	proto.RegisterType((*WriteResponse)(nil), "groupproto.WriteResponse")
	proto.RegisterType((*LookupResponse)(nil), "groupproto.LookupResponse")
	proto.RegisterType((*LookupGroupResponse)(nil), "groupproto.LookupGroupResponse")
	proto.RegisterType((*LookupGroupItem)(nil), "groupproto.LookupGroupItem")
	proto.RegisterType((*ReadGroupResponse)(nil), "groupproto.ReadGroupResponse")
	proto.RegisterType((*ReadGroupItem)(nil), "groupproto.ReadGroupItem")
	proto.RegisterType((*ReadResponse)(nil), "groupproto.ReadResponse")
	proto.RegisterType((*DeleteResponse)(nil), "groupproto.DeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for GroupStore service

type GroupStoreClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error)
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error)
	LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error)
	StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error)
	ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error)
	StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error)
}

type groupStoreClient struct {
	cc *grpc.ClientConn
}

func NewGroupStoreClient(cc *grpc.ClientConn) GroupStoreClient {
	return &groupStoreClient{cc}
}

func (c *groupStoreClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[0], c.cc, "/groupproto.GroupStore/StreamWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamWriteClient{stream}
	return x, nil
}

type GroupStore_StreamWriteClient interface {
	Send(*WriteRequest) error
	Recv() (*WriteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamWriteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamWriteClient) Recv() (*WriteResponse, error) {
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	out := new(LookupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[1], c.cc, "/groupproto.GroupStore/StreamLookup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupClient interface {
	Send(*LookupRequest) error
	Recv() (*LookupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupClient) Send(m *LookupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupClient) Recv() (*LookupResponse, error) {
	m := new(LookupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error) {
	out := new(LookupGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/LookupGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[2], c.cc, "/groupproto.GroupStore/StreamLookupGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupGroupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupGroupClient interface {
	Send(*LookupGroupRequest) error
	Recv() (*LookupGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupGroupClient) Send(m *LookupGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupClient) Recv() (*LookupGroupResponse, error) {
	m := new(LookupGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error) {
	out := new(ReadGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/ReadGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[3], c.cc, "/groupproto.GroupStore/StreamReadGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadGroupClient{stream}
	return x, nil
}

type GroupStore_StreamReadGroupClient interface {
	Send(*ReadGroupRequest) error
	Recv() (*ReadGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadGroupClient) Send(m *ReadGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupClient) Recv() (*ReadGroupResponse, error) {
	m := new(ReadGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[4], c.cc, "/groupproto.GroupStore/StreamRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadClient{stream}
	return x, nil
}

type GroupStore_StreamReadClient interface {
	Send(*ReadRequest) error
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadClient) Send(m *ReadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[5], c.cc, "/groupproto.GroupStore/StreamDelete", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamDeleteClient{stream}
	return x, nil
}

type GroupStore_StreamDeleteClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamDeleteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamDeleteClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteClient) Recv() (*DeleteResponse, error) {
	m := new(DeleteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GroupStore service

type GroupStoreServer interface {
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	StreamWrite(GroupStore_StreamWriteServer) error
	Lookup(context.Context, *LookupRequest) (*LookupResponse, error)
	StreamLookup(GroupStore_StreamLookupServer) error
	LookupGroup(context.Context, *LookupGroupRequest) (*LookupGroupResponse, error)
	StreamLookupGroup(GroupStore_StreamLookupGroupServer) error
	ReadGroup(context.Context, *ReadGroupRequest) (*ReadGroupResponse, error)
	StreamReadGroup(GroupStore_StreamReadGroupServer) error
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	StreamRead(GroupStore_StreamReadServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	StreamDelete(GroupStore_StreamDeleteServer) error
}

func RegisterGroupStoreServer(s *grpc.Server, srv GroupStoreServer) {
	s.RegisterService(&_GroupStore_serviceDesc, srv)
}

func _GroupStore_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamWrite(&groupStoreStreamWriteServer{stream})
}

type GroupStore_StreamWriteServer interface {
	Send(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamWriteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamWriteServer) Send(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Lookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Lookup(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamLookup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookup(&groupStoreStreamLookupServer{stream})
}

type GroupStore_StreamLookupServer interface {
	Send(*LookupResponse) error
	Recv() (*LookupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupServer) Send(m *LookupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupServer) Recv() (*LookupRequest, error) {
	m := new(LookupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_LookupGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).LookupGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/LookupGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).LookupGroup(ctx, req.(*LookupGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamLookupGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookupGroup(&groupStoreStreamLookupGroupServer{stream})
}

type GroupStore_StreamLookupGroupServer interface {
	Send(*LookupGroupResponse) error
	Recv() (*LookupGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupGroupServer) Send(m *LookupGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupServer) Recv() (*LookupGroupRequest, error) {
	m := new(LookupGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_ReadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).ReadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/ReadGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).ReadGroup(ctx, req.(*ReadGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamReadGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamReadGroup(&groupStoreStreamReadGroupServer{stream})
}

type GroupStore_StreamReadGroupServer interface {
	Send(*ReadGroupResponse) error
	Recv() (*ReadGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadGroupServer) Send(m *ReadGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupServer) Recv() (*ReadGroupRequest, error) {
	m := new(ReadGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamRead(&groupStoreStreamReadServer{stream})
}

type GroupStore_StreamReadServer interface {
	Send(*ReadResponse) error
	Recv() (*ReadRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadServer) Recv() (*ReadRequest, error) {
	m := new(ReadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamDelete_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamDelete(&groupStoreStreamDeleteServer{stream})
}

type GroupStore_StreamDeleteServer interface {
	Send(*DeleteResponse) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamDeleteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamDeleteServer) Send(m *DeleteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GroupStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "groupproto.GroupStore",
	HandlerType: (*GroupStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _GroupStore_Write_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _GroupStore_Lookup_Handler,
		},
		{
			MethodName: "LookupGroup",
			Handler:    _GroupStore_LookupGroup_Handler,
		},
		{
			MethodName: "ReadGroup",
			Handler:    _GroupStore_ReadGroup_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _GroupStore_Read_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroupStore_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamWrite",
			Handler:       _GroupStore_StreamWrite_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookup",
			Handler:       _GroupStore_StreamLookup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookupGroup",
			Handler:       _GroupStore_StreamLookupGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamReadGroup",
			Handler:       _GroupStore_StreamReadGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamRead",
			Handler:       _GroupStore_StreamRead_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamDelete",
			Handler:       _GroupStore_StreamDelete_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 597 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xdd, 0x6e, 0xd3, 0x30,
	0x18, 0x25, 0x4d, 0xd2, 0xd1, 0xaf, 0x7f, 0x9b, 0x41, 0x90, 0x8e, 0xf1, 0xa3, 0x5c, 0xa0, 0x5e,
	0x15, 0x18, 0x97, 0x48, 0x48, 0xab, 0x98, 0xf8, 0x19, 0x93, 0x26, 0x0f, 0x09, 0x89, 0x9b, 0x11,
	0x5a, 0xab, 0x8b, 0x96, 0x2c, 0x21, 0x49, 0x11, 0x7b, 0x02, 0x04, 0x2f, 0xc1, 0x05, 0x4f, 0xc0,
	0x4b, 0xf0, 0x5c, 0x38, 0x76, 0xe3, 0xda, 0x4d, 0xd2, 0x49, 0x34, 0xa8, 0xbb, 0x8b, 0x7d, 0xac,
	0xf3, 0x1d, 0x7f, 0xdf, 0x39, 0x6e, 0xa1, 0x3b, 0x89, 0x82, 0x69, 0x78, 0xe2, 0x84, 0xee, 0x20,
	0x8c, 0x82, 0x24, 0x40, 0xc0, 0x36, 0xd8, 0xb7, 0x0d, 0x70, 0x7d, 0xdf, 0x0f, 0x93, 0x8b, 0xc3,
	0x78, 0x62, 0xff, 0xd1, 0xa0, 0xf5, 0x3e, 0x72, 0x13, 0x82, 0xc9, 0xe7, 0x29, 0x89, 0x13, 0x74,
	0x13, 0xcc, 0x28, 0x1c, 0xb9, 0x63, 0x4b, 0x7b, 0xa0, 0xf5, 0xdb, 0x98, 0x2f, 0x10, 0x02, 0xe3,
	0x8c, 0x5c, 0xec, 0x59, 0x35, 0xba, 0x69, 0x60, 0xf6, 0x3d, 0xdb, 0x1b, 0x5a, 0xba, 0xd8, 0x1b,
	0xa2, 0x1d, 0x68, 0x8c, 0x4e, 0x5d, 0x6f, 0x7c, 0x90, 0x1e, 0x36, 0x18, 0x30, 0xdf, 0x90, 0xd1,
	0xa1, 0x65, 0xaa, 0xe8, 0x30, 0xad, 0xfc, 0xc5, 0xf1, 0xa6, 0xc4, 0xaa, 0x53, 0xa4, 0x85, 0xf9,
	0x02, 0x3d, 0x84, 0x4e, 0xe2, 0xfa, 0x54, 0x99, 0xe3, 0x87, 0x87, 0xee, 0x28, 0x0a, 0xac, 0x0d,
	0x0a, 0xeb, 0x78, 0x61, 0xd7, 0xfe, 0xae, 0x41, 0xfb, 0x6d, 0x10, 0x9c, 0x4d, 0xc3, 0xb5, 0xdf,
	0xc4, 0xfe, 0xa6, 0x41, 0x13, 0x13, 0x67, 0xbc, 0x7e, 0x25, 0xbf, 0x69, 0x57, 0x5e, 0x10, 0x8f,
	0x5c, 0x85, 0xf9, 0xe6, 0x27, 0x59, 0x2f, 0x9c, 0x24, 0x06, 0xc4, 0x07, 0xf9, 0x32, 0xb5, 0x6c,
	0x25, 0xba, 0xed, 0x23, 0xd8, 0x4c, 0x07, 0x52, 0x21, 0xe3, 0x09, 0xb4, 0x67, 0xb9, 0x89, 0xc3,
	0xe0, 0x3c, 0x26, 0x25, 0x74, 0xf9, 0x4b, 0xd7, 0x8a, 0x2e, 0x8d, 0x36, 0x41, 0x27, 0x51, 0xc4,
	0x2a, 0x34, 0x70, 0xfa, 0x69, 0x7f, 0x85, 0x4e, 0xe6, 0xe7, 0x4a, 0x2a, 0xdc, 0x82, 0xba, 0x47,
	0xce, 0x27, 0xc9, 0x29, 0x2b, 0xd2, 0xc6, 0xb3, 0x55, 0x56, 0xd9, 0x98, 0x57, 0x0e, 0xe1, 0x86,
	0x32, 0x80, 0xa5, 0xe5, 0x9f, 0x80, 0x49, 0xbb, 0xe0, 0xc7, 0xb4, 0xaa, 0xde, 0x6f, 0xee, 0xde,
	0x19, 0xcc, 0x1f, 0x9a, 0x81, 0xc4, 0xf2, 0x9a, 0x9e, 0xc1, 0xfc, 0x64, 0xc1, 0x5d, 0x7f, 0x69,
	0xd0, 0x5d, 0x38, 0x5c, 0x52, 0x4e, 0x31, 0x60, 0x6d, 0xa9, 0x01, 0xf5, 0xcb, 0x0d, 0x68, 0x5c,
	0xd2, 0x29, 0x53, 0xee, 0x94, 0xed, 0xc1, 0x96, 0x64, 0xa2, 0xa5, 0x5d, 0x79, 0xa4, 0x76, 0xa5,
	0x27, 0x77, 0x45, 0x70, 0x2c, 0xef, 0xc9, 0x4f, 0x1a, 0x5d, 0xe5, 0xe8, 0x1a, 0x3b, 0x22, 0x9e,
	0x66, 0x53, 0x7a, 0x9a, 0xed, 0x04, 0x5a, 0xfc, 0x95, 0xab, 0xc4, 0x9f, 0xa2, 0x86, 0x2e, 0x3f,
	0xff, 0x79, 0x77, 0x7e, 0x84, 0x4e, 0xf6, 0xa2, 0xfd, 0x9f, 0xe4, 0xed, 0xfe, 0xd8, 0x00, 0x60,
	0x5d, 0x3f, 0x4e, 0x82, 0x88, 0xa0, 0xe7, 0x60, 0xb2, 0xa4, 0x23, 0x4b, 0x9e, 0xa2, 0xfc, 0xa3,
	0xb9, 0xdd, 0x2b, 0x40, 0xb8, 0x38, 0xfb, 0x1a, 0x7a, 0x05, 0xcd, 0xe3, 0x24, 0x22, 0x8e, 0xbf,
	0x0a, 0x4b, 0x5f, 0x7b, 0xac, 0xa1, 0x3d, 0xa8, 0xf3, 0x94, 0xa0, 0x5e, 0x3e, 0x66, 0x19, 0xcb,
	0x76, 0x11, 0x24, 0xc4, 0x1c, 0x40, 0x8b, 0x8b, 0x59, 0x91, 0x88, 0xe9, 0x39, 0x82, 0xa6, 0x94,
	0x5a, 0x74, 0xaf, 0x24, 0xfb, 0x19, 0xe1, 0xfd, 0x52, 0x5c, 0xc8, 0xfb, 0x00, 0x5b, 0xb2, 0xbc,
	0xaa, 0x78, 0x99, 0xda, 0x37, 0xd0, 0x10, 0x79, 0x42, 0x3b, 0x85, 0x89, 0xcc, 0x18, 0xef, 0x96,
	0xa0, 0x42, 0xe7, 0x3b, 0xe8, 0x72, 0x9d, 0x55, 0x31, 0x32, 0x85, 0xcf, 0xc0, 0x48, 0x21, 0x74,
	0x7b, 0xf1, 0x70, 0xc6, 0x62, 0xe5, 0x01, 0x21, 0x69, 0x1f, 0x60, 0x2e, 0xe9, 0x9f, 0x28, 0x32,
	0x8f, 0xf1, 0x78, 0xa9, 0xd6, 0x50, 0xfe, 0x44, 0xa8, 0xd6, 0x50, 0xd3, 0x28, 0x7b, 0x6c, 0x45,
	0xa2, 0x54, 0xcf, 0xa7, 0x3a, 0xc3, 0x9e, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x40, 0xb1, 0xd0,
	0x0d, 0xd2, 0x0a, 0x00, 0x00,
}
